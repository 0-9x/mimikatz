/*	Benjamin DELPY `gentilkiwi`
	http://blog.gentilkiwi.com
	benjamin@gentilkiwi.com
	Licence : http://creativecommons.org/licenses/by/3.0/fr/
*/
#include "kuhl_m_dpapi.h"

const KUHL_M_C kuhl_m_c_dpapi[] = {
	{kuhl_m_dpapi_masterkeys,	L"masterkeys",	L"Describe a Masterkeys file"},
	{kuhl_m_dpapi_blob,			L"blob",		L"Describe a DPAPI blob (secret)"},
	{kuhl_m_dpapi_protect,		L"protect",		L"Protect a data via a DPAPI call"},
	{kuhl_m_dpapi_unprotect,	L"unprotect",	L"Unprotect a data via DPAPI call or with a Masterkey/its SHA1"},
	{kuhl_m_dpapi_test,			L"test",		L"Test RSA with DomainKey & AccessCheck"},
};
const KUHL_M kuhl_m_dpapi = {
	L"dpapi",	L"", NULL,
	ARRAYSIZE(kuhl_m_c_dpapi), kuhl_m_c_dpapi, NULL, NULL
};

NTSTATUS kuhl_m_dpapi_masterkeys(int argc, wchar_t * argv[])
{
	PKULL_M_DPAPI_MASTERKEYS masterkeys;
	PBYTE buffer;
	DWORD szBuffer;

	if(argc && kull_m_file_readData(argv[0], &buffer, &szBuffer))
	{
		if(masterkeys = kull_m_dpapi_masterkeys_create(buffer))
		{
			kull_m_dpapi_masterkeys_descr(masterkeys);
			kull_m_dpapi_masterkeys_delete(masterkeys);
		}
		LocalFree(buffer);
	}
	return STATUS_SUCCESS;
}

NTSTATUS kuhl_m_dpapi_blob(int argc, wchar_t * argv[])
{
	PKULL_M_DPAPI_BLOB blob;
	PBYTE buffer;
	DWORD szBuffer;

	if(argc && kull_m_file_readData(argv[0], &buffer, &szBuffer))
	{
		if(blob = kull_m_dpapi_blob_create(buffer))
		{
			kull_m_dpapi_blob_descr(blob);
			kull_m_dpapi_blob_delete(blob);
		}
		LocalFree(buffer);
	}
	return STATUS_SUCCESS;
}

NTSTATUS kuhl_m_dpapi_protect(int argc, wchar_t * argv[])
{
	DATA_BLOB dataIn, dataOut, dataEntropy = {0, NULL};
	PKULL_M_DPAPI_BLOB blob;
	PCWSTR description = NULL, szEntropy, outfile;
	CRYPTPROTECT_PROMPTSTRUCT promptStructure = {sizeof(CRYPTPROTECT_PROMPTSTRUCT), CRYPTPROTECT_PROMPT_ON_PROTECT | CRYPTPROTECT_PROMPT_ON_UNPROTECT | CRYPTPROTECT_PROMPT_STRONG, NULL, MIMIKATZ}, *pPrompt;
	DWORD flags = 0, outputMode = 1;

	kull_m_string_args_byName(argc, argv, L"data", (PCWSTR *) &dataIn.pbData, MIMIKATZ);
	kull_m_string_args_byName(argc, argv, L"description", &description, NULL);
	if(kull_m_string_args_byName(argc, argv, L"entropy", &szEntropy, NULL))
		kull_m_string_stringToHexBuffer(szEntropy, &dataEntropy.pbData, &dataEntropy.cbData);
	if(kull_m_string_args_byName(argc, argv, L"machine", NULL, NULL))
		flags |= CRYPTPROTECT_LOCAL_MACHINE;
	pPrompt = kull_m_string_args_byName(argc, argv, L"prompt", NULL, NULL) ? &promptStructure : NULL;
	
	if(kull_m_string_args_byName(argc, argv, L"c", NULL, NULL))
		outputMode = 2;

	kprintf(L"\ndata        : %s\n", dataIn.pbData);
	kprintf(L"description : %s\n", description ? description : L"");
	kprintf(L"flags       : "); kull_m_dpapi_displayProtectionFlags(flags); kprintf(L"\n");
	kprintf(L"prompt flags: "); if(pPrompt) kull_m_dpapi_displayPromptFlags(pPrompt->dwPromptFlags); kprintf(L"\n");
	kprintf(L"entropy     : "); kull_m_string_wprintf_hex(dataEntropy.pbData, dataEntropy.cbData, 0); kprintf(L"\n\n");

	dataIn.cbData = (DWORD) ((wcslen((PCWSTR) dataIn.pbData) + 1) * sizeof(wchar_t));
	if(CryptProtectData(&dataIn, description, &dataEntropy, NULL, pPrompt, flags, &dataOut))
	{
		if(blob = kull_m_dpapi_blob_create(dataOut.pbData))
		{
			kull_m_dpapi_blob_descr(blob);
			kull_m_dpapi_blob_delete(blob);
		}
		kprintf(L"\n");
		if(kull_m_string_args_byName(argc, argv, L"out", &outfile, NULL))
		{
			if(kull_m_file_writeData(outfile, dataOut.pbData, dataOut.cbData))
				kprintf(L"Write to file \'%s\' is OK\n", outfile);
		}
		else
		{
			kprintf(L"Blob:\n");
			kull_m_string_wprintf_hex(dataOut.pbData, dataOut.cbData, outputMode | (16 << 16));
			kprintf(L"\n");
		}
		LocalFree(dataOut.pbData);
	}
	else PRINT_ERROR_AUTO(L"CryptProtectData");

	if(dataEntropy.pbData)
		LocalFree(dataEntropy.pbData);

	return STATUS_SUCCESS;
}

NTSTATUS kuhl_m_dpapi_unprotect(int argc, wchar_t * argv[])
{
	DATA_BLOB dataIn, dataOut, dataEntropy = {0, NULL};
	PKULL_M_DPAPI_BLOB blob;
	PCWSTR szEntropy, outfile, infile, szMasterkey, szPassword = NULL;
	PWSTR description = NULL;
	CRYPTPROTECT_PROMPTSTRUCT promptStructure = {sizeof(CRYPTPROTECT_PROMPTSTRUCT), CRYPTPROTECT_PROMPT_ON_PROTECT | CRYPTPROTECT_PROMPT_ON_UNPROTECT | CRYPTPROTECT_PROMPT_STRONG, NULL, MIMIKATZ}, *pPrompt;
	DWORD flags = 0;
	UNICODE_STRING uString;

	BOOL statusDecrypt = FALSE;
	PBYTE masterkey = NULL;
	DWORD masterkeyLen = 0;

	if(kull_m_string_args_byName(argc, argv, L"entropy", &szEntropy, NULL))
		kull_m_string_stringToHexBuffer(szEntropy, &dataEntropy.pbData, &dataEntropy.cbData);
	if(kull_m_string_args_byName(argc, argv, L"machine", NULL, NULL))
		flags |= CRYPTPROTECT_LOCAL_MACHINE;
	pPrompt = kull_m_string_args_byName(argc, argv, L"prompt", NULL, NULL) ? &promptStructure : NULL;
	if(kull_m_string_args_byName(argc, argv, L"masterkey", &szMasterkey, NULL))
		kull_m_string_stringToHexBuffer(szMasterkey, &masterkey, &masterkeyLen);
	kull_m_string_args_byName(argc, argv, L"password", &szPassword, NULL);

	kprintf(L"\nflags       : "); kull_m_dpapi_displayProtectionFlags(flags); kprintf(L"\n");
	kprintf(L"prompt flags: "); if(pPrompt) kull_m_dpapi_displayPromptFlags(pPrompt->dwPromptFlags); kprintf(L"\n");
	kprintf(L"entropy     : "); kull_m_string_wprintf_hex(dataEntropy.pbData, dataEntropy.cbData, 0); kprintf(L"\n");
	kprintf(L"masterkey   : "); kull_m_string_wprintf_hex(masterkey, masterkeyLen, 0); kprintf(L"\n");
	kprintf(L"password    : %s\n\n", szPassword ? szPassword : L"");

	if(kull_m_string_args_byName(argc, argv, L"in", &infile, NULL))
	{
		if(kull_m_file_readData(infile, &dataIn.pbData, &dataIn.cbData))
		{
			if(blob = kull_m_dpapi_blob_create(dataIn.pbData))
			{
				kull_m_dpapi_blob_descr(blob);

				if(masterkey && masterkeyLen)
					statusDecrypt = kull_m_dpapi_unprotect_blob(blob, masterkey, masterkeyLen, dataEntropy.pbData, dataEntropy.cbData, szPassword, (LPVOID *) &dataOut.pbData, &dataOut.cbData);
				else
					statusDecrypt = CryptUnprotectData(&dataIn, &description, &dataEntropy, NULL, pPrompt, 0, &dataOut);

				if(statusDecrypt)
				{
					if(description)
					{
						kprintf(L"description : %s\n", description);
						LocalFree(description);
					}

					if(kull_m_string_args_byName(argc, argv, L"out", &outfile, NULL))
					{
						if(kull_m_file_writeData(outfile, dataOut.pbData, dataOut.cbData))
							kprintf(L"Write to file \'%s\' is OK\n", outfile);
					}
					else
					{
						uString.Length = uString.MaximumLength = (USHORT) dataOut.cbData;
						uString.Buffer = (PWSTR) dataOut.pbData;
						kprintf(L"data - ");
						if((uString.Length <= USHRT_MAX) && (kull_m_string_suspectUnicodeString(&uString)))
							kprintf(L"text : %s", dataOut.pbData);
						else
						{
							kprintf(L"hex  : ");
							kull_m_string_wprintf_hex(dataOut.pbData, dataOut.cbData, 1 | (16 << 16));
						}
						kprintf(L"\n");
					}
					LocalFree(dataOut.pbData);
				}
				else if(!masterkey) PRINT_ERROR_AUTO(L"CryptUnprotectData");

				kull_m_dpapi_blob_delete(blob);
			}
			LocalFree(dataIn.pbData);
		}
	}

	if(dataEntropy.pbData)
		LocalFree(dataEntropy.pbData);

	if(masterkey)
		LocalFree(masterkey);

	return STATUS_SUCCESS;
}

BYTE rsa_blob[] = {0x80, 0x87, 0xf0, 0x4f, 0x07, 0xdd, 0x89, 0x4f, 0x37, 0xa4, 0x05, 0x2e, 0x8e, 0x19, 0xdf, 0x22, 0xe2, 0x09, 0x53, 0xe0, 0xfa, 0x87, 0x5b, 0xf3, 0x0a, 0x37, 0x01, 0x89, 0x20, 0xb2, 0xfa, 0x45, 0xf6, 0xd3, 0x31, 0x95, 0xd8, 0xf6, 0x5b, 0x3a, 0xe0, 0xd9, 0xe0, 0x3a, 0xca, 0x51, 0xfc, 0x5a, 0x00, 0x7c, 0x42, 0xa8, 0x13, 0x9f, 0x37, 0x36, 0xde, 0xfa, 0xab, 0x7c, 0x60, 0x34, 0x3d, 0x3a, 0xac, 0x69, 0xf0, 0xb7, 0x6f, 0x16, 0x53, 0x88, 0x22, 0x2e, 0x98, 0xe7, 0x13, 0x9f, 0x22, 0x8f, 0x51, 0x02, 0xa8, 0x2e, 0xdb, 0x9c, 0x83, 0x18, 0xd8, 0x73, 0x7f, 0x23, 0xb1, 0x5d, 0x01, 0x4d, 0xea, 0xf2, 0xa7, 0x48, 0x83, 0xc0, 0x06, 0x9c, 0xb5, 0x53, 0x0f, 0xe3, 0x9a, 0x7b, 0xc0, 0xb6, 0x55, 0x21, 0x9b, 0x69, 0x2b, 0xbe, 0x76, 0x3c, 0x30, 0x0d, 0x55, 0xef, 0xfc, 0x10, 0x2e, 0x9f, 0xd3, 0xf3, 0x35, 0x5f, 0x16, 0x4e, 0xc0, 0xc4, 0x99, 0xa7, 0x2d, 0x08, 0x99, 0xb7, 0x8e, 0x20, 0xb6, 0xed, 0xc1, 0xb8, 0xd8, 0x52, 0xf1, 0x13, 0xec, 0x2a, 0x42, 0x2d, 0x05, 0xb6, 0x17, 0x82, 0xce, 0x2b, 0xc3, 0x93, 0xf9, 0x22, 0x0a, 0x9d, 0x5b, 0x30, 0x5f, 0x64, 0xaa, 0x52, 0x43, 0xaf, 0xca, 0x94, 0x9a, 0x13, 0x89, 0xc7, 0xb1, 0x8c, 0xce, 0x4b, 0x50, 0x84, 0x75, 0x4e, 0x5f, 0x01, 0xc2, 0x50, 0xfb, 0x63, 0x40, 0x60, 0x81, 0x7c, 0x4a, 0x8d, 0x96, 0x21, 0x21, 0x00, 0xef, 0xfa, 0xbf, 0xfd, 0xbe, 0xbe, 0x4d, 0x0a, 0x80, 0x4e, 0xe1, 0x5a, 0xdf, 0x0d, 0x70, 0xee, 0xd1, 0x58, 0xf5, 0xf6, 0xb4, 0x7d, 0x96, 0xb3, 0xd2, 0xf9, 0xcb, 0x23, 0x1e, 0x8e, 0x75, 0xad, 0x68, 0x91, 0x81, 0x87, 0x26, 0xf6, 0xf5, 0xb0, 0x11, 0xcb, 0x87, 0x95, 0xc4, 0xff, 0xcb, 0xb4, 0x37, 0x25};
BYTE access_check[] = {0x3e, 0xbe, 0x6c, 0xd4, 0x4b, 0xaf, 0x14, 0xf9, 0xc6, 0xfb, 0x62, 0xa9, 0xa1, 0x58, 0x28, 0x73, 0x6a, 0x41, 0xef, 0xe0, 0x5d, 0x08, 0xaf, 0x6b, 0x68, 0x58, 0x9d, 0xd1, 0x82, 0xe8, 0xb5, 0x81, 0xe7, 0x79, 0x3a, 0x69, 0x34, 0x95, 0x92, 0x92, 0xdf, 0x55, 0x5b, 0x4b, 0xa8, 0xfb, 0x1f, 0x6f, 0xe4, 0xe0, 0x8c, 0x4f, 0x18, 0x87, 0x6b, 0xfa, 0x9a, 0x4d, 0x30, 0x1d, 0x8f, 0x0e, 0xa5, 0x38, 0xa1, 0x28, 0x23, 0x0c, 0x52, 0x25, 0xf7, 0xab, 0x3f, 0xe5, 0x8c, 0x1c, 0xbb, 0x43, 0xf3, 0x84, 0x1c, 0x5b, 0xc4, 0xce, 0xea, 0x6d, 0x2f, 0x7d};
BYTE rsa_key[] = {0x07, 0x02, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00, 0x52, 0x53, 0x41, 0x32, 0x00, 0x08, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0xab, 0xed, 0xad, 0x45, 0x13, 0x41, 0x42, 0xcd, 0x8c, 0xd3, 0xe9, 0xdd, 0x45, 0xff, 0x90, 0x74, 0x34, 0x52, 0x1d, 0x61, 0x8c, 0xc1, 0xbe, 0x07, 0x64, 0x73, 0x75, 0xfe, 0x5f, 0x63, 0x2e, 0x3d, 0x4a, 0x58, 0xb1, 0x53, 0xb5, 0x8e, 0x6e, 0x06, 0xda, 0x3e, 0x1b, 0x2d, 0xde, 0x23, 0x22, 0xf2, 0xff, 0xe3, 0xa7, 0xf1, 0x8e, 0xf8, 0x26, 0x20, 0x42, 0xef, 0x1b, 0x05, 0x2b, 0x16, 0x7a, 0xd8, 0xe4, 0xdf, 0x99, 0xcc, 0xfe, 0x33, 0x63, 0x6d, 0x1d, 0x2b, 0xc4, 0xc3, 0x83, 0x22, 0x6e, 0x77, 0x2a, 0x79, 0x4d, 0x05, 0xe4, 0xc4, 0x9b, 0xdd, 0xe6, 0xd6, 0x06, 0xe7, 0xe0, 0xb0, 0x7b, 0x34, 0xc9, 0xf1, 0xe7, 0x91, 0x12, 0xff, 0xae, 0xc2, 0x48, 0xb9, 0x19, 0xee, 0xd1, 0xc0, 0x38, 0x00, 0x92, 0x5d, 0x69, 0xc1, 0x72, 0xbe, 0xce, 0x10, 0x3b, 0xf9, 0x20, 0xfb, 0xf1, 0x29, 0xc5, 0xd5, 0x0b, 0x93, 0x17, 0x9f, 0xb6, 0x97, 0x14, 0x60, 0x30, 0x00, 0xd0, 0xdb, 0xc4, 0x45, 0x73, 0xd1, 0x4c, 0x61, 0x80, 0x27, 0xce, 0xfe, 0xf0, 0xb0, 0x82, 0x00, 0xcd, 0x17, 0x38, 0x0e, 0xfc, 0x5a, 0x47, 0x4f, 0xf9, 0x4f, 0x9e, 0xd5, 0x92, 0xcc, 0x1d, 0x18, 0x31, 0x2d, 0x12, 0x61, 0xa4, 0x12, 0xb0, 0xb8, 0x64, 0x96, 0x67, 0x7d, 0x31, 0x10, 0x21, 0x21, 0x39, 0xda, 0x7e, 0x18, 0xf4, 0x47, 0xaf, 0xe7, 0xc9, 0x3e, 0xef, 0xf8, 0x1d, 0x98, 0x63, 0x81, 0xb2, 0x08, 0xb3, 0x11, 0x6f, 0xc3, 0x09, 0xe9, 0xc1, 0x55, 0xf3, 0x0c, 0xbf, 0x3e, 0x21, 0x12, 0x79, 0x86, 0x24, 0x66, 0x69, 0x24, 0xea, 0x10, 0x14, 0x09, 0xad, 0x75, 0x67, 0xa1, 0xbc, 0x74, 0x2c, 0xc3, 0x3d, 0xe0, 0xd8, 0x9e, 0x07, 0x81, 0x61, 0x2c, 0xd7, 0x36, 0x59, 0x96, 0x71, 0x96, 0x54, 0xa7, 0x48, 0x38, 0xa9, 0xbc, 0xc5, 0xf5, 0x04, 0x61, 0x9e, 0xa6, 0x89, 0x7b, 0x7c, 0x69, 0x0c, 0x31, 0x65, 0xf2, 0x11, 0x70, 0xdc, 0x72, 0x7d, 0xb3, 0xa6, 0x45, 0x06, 0xd9, 0x0a, 0xd9, 0x80, 0xdb, 0x85, 0x1a, 0x04, 0x9d, 0xf4, 0xfe, 0xb0, 0x7d, 0xfd, 0x69, 0xb1, 0xf6, 0xda, 0x2c, 0x95, 0x27, 0xc1, 0x5e, 0x22, 0x10, 0x75, 0xd6, 0xe8, 0xe9, 0x54, 0x42, 0xe3, 0x8a, 0x32, 0xa2, 0xe6, 0xbe, 0x89, 0xf7, 0xf7, 0x7b, 0x59, 0xd8, 0xb9, 0xfa, 0x66, 0x34, 0x80, 0x8b, 0xee, 0x6e, 0xb4, 0x29, 0x2a, 0xa9, 0xfe, 0x05, 0x0f, 0xf2, 0x13, 0xdc, 0x56, 0x06, 0x40, 0xec, 0x76, 0x56, 0x36, 0x55, 0x68, 0xc6, 0x69, 0x2d, 0x27, 0x36, 0xa7, 0x27, 0x10, 0xb4, 0xef, 0x1b, 0x8c, 0x47, 0x69, 0xd9, 0x3b, 0x55, 0x58, 0xef, 0xaa, 0x8a, 0xed, 0x4e, 0x41, 0x77, 0x1e, 0xba, 0x35, 0xb2, 0x6d, 0xb5, 0xc1, 0x2f, 0x81, 0xf0, 0xaf, 0xfc, 0xac, 0x3d, 0x55, 0x3f, 0x59, 0xc2, 0xf2, 0x67, 0x7b, 0x57, 0xc4, 0x08, 0x51, 0x06, 0x0a, 0xce, 0xec, 0xae, 0xf8, 0xfb, 0xd2, 0xbf, 0xdd, 0x9d, 0xa0, 0xf2, 0x2d, 0x29, 0x3f, 0xd1, 0x3e, 0xa0, 0x3d, 0xcb, 0xa4, 0x01, 0xa3, 0x94, 0xdf, 0xfd, 0x2a, 0x05, 0x5d, 0x46, 0x41, 0xb2, 0x7b, 0xeb, 0x8c, 0xff, 0x33, 0x70, 0xaa, 0xdf, 0x7f, 0x08, 0x47, 0x95, 0x2c, 0x45, 0xc0, 0x7d, 0xb7, 0x4b, 0x68, 0xa5, 0x3b, 0x51, 0x58, 0x91, 0x20, 0x4f, 0x80, 0xdf, 0x78, 0x84, 0x1e, 0xdb, 0xe2, 0xe2, 0xa1, 0xf6, 0x7f, 0xe4, 0x46, 0x60, 0x77, 0xbd, 0x55, 0x87, 0xdc, 0x8f, 0x15, 0xcf, 0x0d, 0xcd, 0x22, 0x72, 0x80, 0xee, 0x89, 0xeb, 0xca, 0x12, 0x70, 0x1a, 0x7e, 0x24, 0x04, 0xa1, 0xff, 0xdd, 0xb5, 0xe1, 0x27, 0x25, 0xd8, 0xba, 0x9c, 0x2a, 0xbb, 0x41, 0x92, 0xf0, 0xd0, 0xc8, 0xd9, 0x19, 0xc8, 0xac, 0xe9, 0xfb, 0xf8, 0x7c, 0xae, 0xcb, 0x8e, 0xe5, 0x78, 0x47, 0x32, 0x14, 0x7d, 0xc4, 0x4b, 0xe6, 0xcf, 0x2f, 0xfa, 0x9c, 0x14, 0xab, 0xa0, 0x47, 0x98, 0x0c, 0x22, 0x6b, 0xfd, 0x91, 0x67, 0xe9, 0x40, 0x56, 0x30, 0x85, 0xd5, 0x02, 0x0c, 0x7e, 0xc1, 0xd6, 0x0d, 0x2d, 0x80, 0x33, 0xbe, 0xd8, 0x54, 0x60, 0x66, 0x3b, 0xb8, 0x99, 0x82, 0x4e, 0x8b, 0xdf, 0x2d, 0x6d, 0x73, 0xaa, 0x87, 0x1b, 0xb6, 0x35, 0xb5, 0x83, 0xe6, 0xce, 0xba, 0x51, 0xff, 0xd1, 0x12, 0x78, 0xb7, 0xf9, 0x70, 0xbf, 0xcd, 0x5f, 0x22, 0xa1, 0xa1, 0xc1, 0x66, 0xc4, 0xbf, 0x54, 0xa0, 0xa6, 0x9a, 0xbc, 0x5d, 0x8c, 0x83, 0xae, 0xed, 0xe2, 0x40, 0x73, 0x52, 0x0b, 0xe8, 0x77, 0xe1, 0x39, 0x08, 0xd6, 0x49, 0x31, 0xda, 0xb3, 0xe6, 0x4d, 0x57, 0xa1, 0x6c, 0x2a, 0x4e, 0x2d, 0x6e, 0x82, 0x51, 0x7a, 0xc9, 0x72, 0x79, 0xc3, 0x37, 0x48, 0x49, 0x08, 0x78, 0xbe, 0xa3, 0x17, 0x8a, 0x18, 0x6c, 0x9a, 0xf7, 0x92, 0xb9, 0x63, 0x7d, 0xee, 0x6f, 0x0f, 0x23, 0xf4, 0xa7, 0x29, 0x7c, 0xab, 0xa2, 0x59, 0x2c, 0xf1, 0xae, 0x23, 0xa5, 0x95, 0xf4, 0x92, 0xb8, 0x48, 0x4a, 0x8a, 0xa1, 0xbb, 0x76, 0x1a, 0xaf, 0x94, 0xe7, 0x0b, 0x84, 0x71, 0xe2, 0xc5, 0x2f, 0x73, 0x0a, 0x6c, 0x07, 0xca, 0x3d, 0x24, 0xbf, 0xc5, 0x29, 0xd2, 0xd6, 0x09, 0xc2, 0x1d, 0xa7, 0x88, 0xfc, 0xd8, 0x38, 0x20, 0x90, 0x96, 0x13, 0x9c, 0xf4, 0x49, 0x2e, 0xe0, 0x4f, 0xe5, 0x5c, 0x62, 0x7b, 0x84, 0x23, 0xa0, 0x02, 0x64, 0xd0, 0x77, 0xe6, 0xac, 0xe3, 0x3a, 0x1b, 0xbc, 0x5d, 0x1a, 0x4a, 0x9c, 0x55, 0x1f, 0x27, 0x74, 0x3f, 0x81, 0x34, 0x5f, 0xb7, 0xc4, 0xf1, 0x04, 0xbc, 0x50, 0xd4, 0x5c, 0xef, 0x7f, 0xed, 0xec, 0x3f, 0x3e, 0x3d, 0xed, 0xdb, 0xcf, 0x64, 0x6f, 0x22, 0xb4, 0xde, 0x88, 0xbc, 0xa5, 0xe0, 0x87, 0x33, 0x75, 0xd7, 0xab, 0xc9, 0x65, 0x5d, 0x9f, 0x60, 0x5b, 0x7a, 0x84, 0x40, 0xed, 0x24, 0x63, 0xc1, 0xc9, 0x2c, 0xc1, 0xed, 0xc5, 0xfc, 0x70, 0xc5, 0x92, 0xa0, 0x5c, 0x0c, 0x22, 0xb5, 0x0e, 0xc6, 0x66, 0x8f, 0x3d, 0x68, 0x80, 0x95, 0xc0, 0x56, 0x49, 0x37, 0x55, 0x1f, 0x70, 0x2b, 0xc7, 0x9c, 0x62, 0xb4, 0x83, 0x0d, 0x0f, 0xc8, 0x9b, 0x0b, 0x23, 0xb1, 0x31, 0xe2, 0x8e, 0x0e, 0x1f, 0x91, 0x85, 0x99, 0x64, 0xfa, 0xe5, 0x1f, 0x49, 0xae, 0x1c, 0x8b, 0x11, 0xc5, 0xe0, 0x9f, 0x1e, 0xdd, 0x82, 0x5a, 0x13, 0xd2, 0xd7, 0xae, 0xca, 0xd3, 0x44, 0x4d, 0xd8, 0x06, 0xe7, 0xbe, 0xa9, 0x30, 0x85, 0x4e, 0xb7, 0x6c, 0x1e, 0x8c, 0xf1, 0xc7, 0xad, 0x27, 0x61, 0xf9, 0xb7, 0xa9, 0x16, 0x73, 0x34, 0x88, 0x42, 0xc0, 0xe3, 0xc2, 0x01, 0x4a, 0xe7, 0xab, 0xad, 0x69, 0xda, 0x9e, 0x52, 0xd8, 0xc3, 0xb6, 0x5e, 0x08, 0xa7, 0x7f, 0xaa, 0xbb, 0xed, 0x40, 0x6d, 0xe6, 0x1f, 0x78, 0x0e, 0xd9, 0xcb, 0x45, 0x1b, 0x4d, 0x56, 0x87, 0xa8, 0x1b, 0xe2, 0x2a, 0xa2, 0x69, 0x39, 0xd1, 0x03, 0xf7, 0xad, 0xf1, 0xd2, 0x40, 0x2e, 0x17, 0x70, 0xdf, 0xbc, 0xb1, 0x8f, 0x8f, 0x36, 0x09, 0x52, 0x79, 0x4b, 0x4c, 0x9d, 0x97, 0x48, 0x9b, 0xe5, 0x86, 0x55, 0x7f, 0x2a, 0x07, 0xa8, 0x6c, 0xd4, 0xc3, 0x65, 0xe5, 0xda, 0x7f, 0xb7, 0xd3, 0x28, 0x5b, 0x86, 0xb9, 0x7c, 0x3c, 0xe8, 0x04, 0xc7, 0x54, 0x47, 0x60, 0xa2, 0xc3, 0x83, 0xe1, 0x32, 0xb0, 0x1a, 0x2e, 0x13, 0x01, 0xac, 0x5c, 0x4f, 0x69, 0x98, 0x77, 0x3d, 0x82, 0x39, 0xe7, 0x1d, 0x0b, 0xdd, 0x57, 0xf7, 0xd1, 0x1f, 0x17, 0x73, 0x5d, 0xbb, 0x71, 0xc7, 0x2f, 0xd3, 0x46, 0xa6, 0x2c, 0xfb, 0x68, 0xd7, 0x12, 0x43, 0x5c, 0xc4, 0x20, 0x89, 0x5f, 0x7f, 0xbd, 0xdf, 0x3d, 0x83, 0x12, 0x1b, 0x4b, 0x56, 0x2e, 0x92, 0xcf, 0x1a, 0x2d, 0x5a, 0xab, 0x63, 0x22, 0x0c, 0xc6, 0x5f, 0xe8, 0x8d, 0x4c, 0x43, 0x18, 0x81, 0x4e, 0x4c, 0xa1, 0xf1, 0x00, 0xd6, 0xf3, 0xe7, 0xf8, 0x3a, 0x73, 0x2d, 0xf3, 0x36, 0x2b, 0xc6, 0xac, 0x25, 0xb2, 0x54, 0x3d, 0xc2, 0xda, 0x2c, 0x5b, 0xdd, 0xc5, 0x0c, 0x13, 0x62, 0x1f, 0x01, 0x65, 0xcd, 0xfa, 0xfe, 0x26, 0x1f, 0xa4, 0x93, 0xa0, 0xc5, 0x77, 0xbe, 0x1c, 0x53, 0xd4, 0x2a, 0x47, 0xd6, 0xab, 0x15, 0xe2, 0x96, 0x66, 0x1a, 0xe5, 0x4d, 0x81, 0x4c, 0x1a, 0xc3, 0x88, 0xea, 0x94, 0x84, 0x32, 0x80, 0x22, 0xd6, 0x38, 0x94, 0x46, 0x96, 0x03, 0x12, 0xd9, 0xcd, 0x8c, 0x0d};
/* this is a test domain ;) */ 
typedef struct _KIWI_RSA_MASTER_KEY {
       DWORD  cbMasterKey;
       DWORD  cbSuppKey;
       BYTE   buffer[ANYSIZE_ARRAY];
} KIWI_RSA_MASTER_KEY, *PKIWI_RSA_MASTER_KEY;
 
typedef struct _KIWI_ACCESS_CHECK {
       DWORD  dwVersion;
       DWORD  dataLen;
       BYTE   data[ANYSIZE_ARRAY];
       // sid
       // SHA1 (or SHA512)
} KIWI_ACCESS_CHECK, *PKIWI_ACCESS_CHECK;
 
NTSTATUS kuhl_m_dpapi_test(int argc, wchar_t * argv[])
{
	DWORD outSize;
	PKIWI_RSA_MASTER_KEY rsa_buffer = (PKIWI_RSA_MASTER_KEY) rsa_blob;
	PKIWI_ACCESS_CHECK des_buffer = (PKIWI_ACCESS_CHECK) access_check;
	BYTE digest[SHA_DIGEST_LENGTH];
	HCRYPTPROV hProv, hSessionProv;
	HCRYPTKEY hKey, hSessionKey;

	if(CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT))
	{
		if(CryptImportKey(hProv, rsa_key, sizeof(rsa_key), 0, 0, &hKey))
		{
			outSize = sizeof(rsa_blob);
			if(CryptDecrypt(hKey, 0, TRUE, 0, rsa_blob, &outSize))
			{
				kprintf(L"\nRSA decrypt is a success\n");
				kprintf(L" * MasterKey len: %u\n", rsa_buffer->cbMasterKey);
				kull_m_string_wprintf_hex(rsa_buffer->buffer, rsa_buffer->cbMasterKey, 1 | (16 << 16));
				kprintf(L" * SuppKey   len: %u\n", rsa_buffer->cbSuppKey);
				kull_m_string_wprintf_hex(rsa_buffer->buffer + rsa_buffer->cbMasterKey, rsa_buffer->cbSuppKey, 1 | (16 << 16));

				if(kull_m_crypto_hkey(hProv, CALG_3DES, rsa_buffer->buffer + rsa_buffer->cbMasterKey, 192 / 8, 0, &hSessionKey, &hSessionProv))
				{
					if(CryptSetKeyParam(hSessionKey, KP_IV, rsa_buffer->buffer + rsa_buffer->cbMasterKey + 192 / 8, 0))
					{
						outSize = sizeof(access_check);
						if(CryptDecrypt(hSessionKey, 0, FALSE, 0, access_check, &outSize))
						{
							kprintf(L"\n3DES decrypt is a success too\n");
							//kull_m_string_wprintf_hex(des_buffer, outSize, 1 | (16 << 16)); kprintf(L"\n");
							kprintf(L" * nonce    : "); kull_m_string_wprintf_hex(des_buffer->data, des_buffer->dataLen, 0); kprintf(L"\n"); // try to leave it as is =)
							kprintf(L" * SID      : "); kull_m_string_displaySID(des_buffer->data + des_buffer->dataLen); kprintf(L"\n");
							kprintf(L" * SHA1     : "); kull_m_string_wprintf_hex((PBYTE) des_buffer + outSize - SHA_DIGEST_LENGTH, SHA_DIGEST_LENGTH, 0); kprintf(L"\n");

							if(kull_m_crypto_hash(CALG_SHA1, des_buffer, outSize - SHA_DIGEST_LENGTH, digest, SHA_DIGEST_LENGTH))
							{
								kprintf(L" > Calc SHA1: "); kull_m_string_wprintf_hex(digest, SHA_DIGEST_LENGTH, 0); kprintf(L"\n");
							}
						}
						else PRINT_ERROR_AUTO(L"CryptDecrypt");
					}
					else PRINT_ERROR_AUTO(L"CryptSetKeyParam");
					CryptDestroyKey(hSessionKey);
					if(!kull_m_crypto_close_hprov_delete_container(hSessionProv))
						PRINT_ERROR_AUTO(L"kull_m_crypto_close_hprov_delete_container");
				}
			}
			else PRINT_ERROR_AUTO(L"CryptDecrypt");
			CryptDestroyKey(hKey);
		}
		CryptReleaseContext(hProv, 0);
	}
	return STATUS_SUCCESS;
}